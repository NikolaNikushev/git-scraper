{"url":"https://api.github.com/repos/willmcgugan/rich/issues/90","repository_url":"https://api.github.com/repos/willmcgugan/rich","labels_url":"https://api.github.com/repos/willmcgugan/rich/issues/90/labels{/name}","comments_url":"https://api.github.com/repos/willmcgugan/rich/issues/90/comments","events_url":"https://api.github.com/repos/willmcgugan/rich/issues/90/events","html_url":"https://github.com/willmcgugan/rich/issues/90","id":623777258,"node_id":"MDU6SXNzdWU2MjM3NzcyNTg=","number":90,"title":"Deadlock when exiting Progress context","user":{"login":"eulertour","id":43117506,"node_id":"MDQ6VXNlcjQzMTE3NTA2","avatar_url":"https://avatars1.githubusercontent.com/u/43117506?v=4","gravatar_id":"","url":"https://api.github.com/users/eulertour","html_url":"https://github.com/eulertour","followers_url":"https://api.github.com/users/eulertour/followers","following_url":"https://api.github.com/users/eulertour/following{/other_user}","gists_url":"https://api.github.com/users/eulertour/gists{/gist_id}","starred_url":"https://api.github.com/users/eulertour/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/eulertour/subscriptions","organizations_url":"https://api.github.com/users/eulertour/orgs","repos_url":"https://api.github.com/users/eulertour/repos","events_url":"https://api.github.com/users/eulertour/events{/privacy}","received_events_url":"https://api.github.com/users/eulertour/received_events","type":"User","site_admin":false},"labels":[],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2020-05-24T02:03:38Z","updated_at":"2020-05-24T21:13:10Z","closed_at":"2020-05-24T14:09:40Z","author_association":"NONE","active_lock_reason":null,"body":"I can consistently reproduce this by letting the following script run. Eventually the progress bars will hang when they're nearly full, like so:\r\n\r\n![deadlock](https://user-images.githubusercontent.com/43117506/82743832-85102500-9d25-11ea-8a92-8b8472f12dde.png)\r\n\r\n```python\r\nfrom rich.progress import track\r\nfrom rich.progress import Progress\r\nimport random\r\nimport time\r\n\r\nwhile True:\r\n    with Progress() as progress:\r\n        task1 = progress.add_task(f\"[red]Downloading...\", total=10)\r\n        task2 = progress.add_task(\"[green]Processing...\", total=10)\r\n        task3 = progress.add_task(\"[cyan]Cooking...\", total=10)\r\n\r\n        while not progress.finished:\r\n            progress.update(task1, advance=random.random())\r\n            progress.update(task2, advance=random.random())\r\n            progress.update(task3, advance=random.random())\r\n            time.sleep(0.1)\r\n```\r\n\r\nI believe the problematic sequence of events is as follows:\r\n1. The main thread exits from a `Progress` context and acquires `Progress._lock` in `Progress.__exit__()`\r\nhttps://github.com/willmcgugan/rich/blob/55988c6e721cc03ab4f6dc6aeca3089e7c5c13ae/rich/progress.py#L447-L451\r\n\r\n2. The refresh thread finishes waiting on `_RefreshThread.done` and calls `Progress.refresh()`, at which point it starts waiting for `Progress._lock`\r\nhttps://github.com/willmcgugan/rich/blob/55988c6e721cc03ab4f6dc6aeca3089e7c5c13ae/rich/progress.py#L346-L348\r\nhttps://github.com/willmcgugan/rich/blob/55988c6e721cc03ab4f6dc6aeca3089e7c5c13ae/rich/progress.py#L574-L582\r\n\r\n3. The main thread calls `Progress._refresh_thread.stop()` in `Progress.stop()`, at which point it waits for the refresh thread to finish with `_RefreshThread.join()`\r\nhttps://github.com/willmcgugan/rich/blob/55988c6e721cc03ab4f6dc6aeca3089e7c5c13ae/rich/progress.py#L422-L436\r\nhttps://github.com/willmcgugan/rich/blob/55988c6e721cc03ab4f6dc6aeca3089e7c5c13ae/rich/progress.py#L342-L344\r\n\r\nAt this point the main thread is holding `Progress._lock` and waiting on the refresh thread to finish while the refresh thread is waiting to acquire `Progress._lock` so it can finish.\r\n\r\nI don't think it's safe to call `_RefreshThread.join()` while holding `Progress._lock`, because there's always a chance that the refresh thread started waiting on `Progress._lock` the nanosecond after it was acquired.","closed_by":{"login":"willmcgugan","id":554369,"node_id":"MDQ6VXNlcjU1NDM2OQ==","avatar_url":"https://avatars3.githubusercontent.com/u/554369?v=4","gravatar_id":"","url":"https://api.github.com/users/willmcgugan","html_url":"https://github.com/willmcgugan","followers_url":"https://api.github.com/users/willmcgugan/followers","following_url":"https://api.github.com/users/willmcgugan/following{/other_user}","gists_url":"https://api.github.com/users/willmcgugan/gists{/gist_id}","starred_url":"https://api.github.com/users/willmcgugan/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/willmcgugan/subscriptions","organizations_url":"https://api.github.com/users/willmcgugan/orgs","repos_url":"https://api.github.com/users/willmcgugan/repos","events_url":"https://api.github.com/users/willmcgugan/events{/privacy}","received_events_url":"https://api.github.com/users/willmcgugan/received_events","type":"User","site_admin":false},"performed_via_github_app":null}